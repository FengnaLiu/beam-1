<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <link rel="stylesheet" href="../github.css">
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<style type="text/css">
  .head { 
    border-left:5px solid #00f;
    padding:3px 0 3px 10px;
    font-weight: bold;
  }
  .lhead { 
    border-left:5px solid #00f;
    padding:3px 0 3px 10px;
    font-size:14pt;
    font-weight: bold;
  }
</style>
<p><a href="../index.html">topへ</a></p>
<h1 id="pcollectionの作成">PCollectionの作成</h1>
<h2 id="pcollectionとは">PCollectionとは？？</h2>
<p>すでに触れてる通り、<code>pipeline</code>に流すdatasetのことを<code>PCollection</code>といいます。<code>PCollection</code>は決まったデータ構造を持つ配列みたいなものです。<br />
たとえば社員の給料を扱いたいとき、<code>PCollection</code>は社員の名前と給料を要素とした、データの寄せ集めになります。</p>
<h2 id="外部リソースの読み込み"><span class="head">外部リソースの読み込み</span></h2>
<p>しばらく使うつもりがないので、詳しくは5章で説明します。</p>
<p><code>PCollection</code>を作るにも、読み込み用の<code>PTransform</code>を<code>pipeline</code>に適用することになる。なので一番初めは、<code>pipeline</code> objectに対して<code>PTransform</code>を適用する、って意味でやや特殊。code上では特殊感はありませんが...</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java"><span class="kw">import</span><span class="im"> org.apache.beam.sdk.Pipeline;</span>
<span class="kw">import</span><span class="im"> org.apache.beam.sdk.options.PipelineOptions;</span>
<span class="kw">import</span><span class="im"> org.apache.beam.sdk.values.PCollection;</span>
<span class="kw">import</span><span class="im"> org.apache.beam.sdk.io.TextIO;</span>

<span class="kw">public</span> <span class="kw">class</span> Main {
  <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span>(<span class="bu">String</span>[] args){
    Pipeline pipeline = Pipeline.<span class="fu">create</span>( opt );
    <span class="co">//</span>
    <span class="co">// file読み込み</span>
    PCollection&lt;<span class="bu">String</span>&gt; col = pipeline
      .<span class="fu">apply</span>(<span class="st">&quot;ReadFromFile&quot;</span>,TextIO.<span class="fu">read</span>().<span class="fu">from</span>(<span class="st">&quot;input.txt&quot;</span>));
    }
}</code></pre></div>
<p>同じメソッドでGCS上のファイルも読み込める。<code>read</code>の引数をGCSのパス、たとえば&quot;gs://komiya-no-test/input.txt&quot;みたいのに変更するだけ。 <code>apply</code>の第一引数の&quot;ReadFromLoacalFile&quot;は処理につけるラベル。Dataflowで見れるgraphとかにラベルがつけられる。省略可。</p>
<p>GCSの場合、ローカルで実行すると認証エラー。回避するには、</p>
<ol type="1">
<li>プロジェクトのオーナー権限を持ったサービスアカウントの作成</li>
<li>キーファイルの作成</li>
<li>キーファイルのパスを環境変数<code>GOOGLE_APPLICATION_CREDENTIAL</code>にexport</li>
</ol>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="bu">export</span> <span class="va">GOOGLE_APPLICATION_CREDENTIAL=</span>/path/to/credential/file</code></pre></div>
<p>IntelliJで環境変数の設定も可能です。気が向けば書きます。</p>
<h2 id="in-memoryデータの読み込み"><span class="head">in-memoryデータの読み込み</span></h2>
<p>dataをソースにベタ打ちしてもok。リストを<code>Create.of</code>に渡してあげればよい。リストの各要素が、テキストファイルの一行として扱われます。</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java"><span class="kw">import</span><span class="im"> java.util.*;</span>
<span class="co">// pipeline</span>
<span class="kw">import</span><span class="im"> org.apache.beam.sdk.Pipeline;</span>
<span class="kw">import</span><span class="im"> org.apache.beam.sdk.options.PipelineOptions;</span>
<span class="kw">import</span><span class="im"> org.apache.beam.sdk.options.PipelineOptionsFactory;</span>
<span class="co">// for passing the in-memory data to pipeline</span>
<span class="kw">import</span><span class="im"> org.apache.beam.sdk.transforms.Create;</span>
<span class="kw">import</span><span class="im"> org.apache.beam.sdk.coders.StringUtf8Coder;</span>

<span class="kw">public</span> <span class="kw">class</span> Main {
    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span>( <span class="bu">String</span>[] args ){
        <span class="co">// input source</span>
        <span class="dt">final</span> <span class="bu">List</span>&lt;<span class="bu">String</span>&gt; input = <span class="bu">Arrays</span>.<span class="fu">asList</span>(
            <span class="st">&quot;To be, or not to be: that is the question: &quot;</span>,
            <span class="st">&quot;Whether &#39;tis nobler in the mind to suffer &quot;</span>,
            <span class="st">&quot;The slings and arrows of outrageous fortune, &quot;</span>,
            <span class="st">&quot;Or to take arms against a sea of troubles, &quot;</span> );
        <span class="co">// create pipeline</span>
        Pipeline pipeline = Pipeline.<span class="fu">create</span>();
        <span class="co">// read</span>
        pipeline.<span class="fu">apply</span>(<span class="st">&quot;ReadFromInMemoryData&quot;</span>,Create.<span class="fu">of</span>(input));
    }
}</code></pre></div>
<h2 id="pcollectionについて少し詳しく">PCollectionについて少し詳しく</h2>
<p>二つ目は言ってることが良くわからん...</p>
<ul>
<li><code>PCollection</code>は一つの<code>Pipeline</code>に帰属。複数の<code>Pipeline</code>での共有は不可。</li>
<li><code>PCollection</code>の関数は、ある意味クラスっぽく振る舞う。</li>
</ul>
<p>まあ、以下の<code>PCollection</code>の性質は押さえておけば良さげ。</p>
<h3 id="要素の型"><span class="head">要素の型</span></h3>
<p><code>Pcollection</code>の型はなんでもよいですが、統一しなきゃだめです。<br />
Beamでは分散処理を行う上で、各worker（処理を行うもの）にdataを渡すために、dataをbyte列に変換する必要があります。 幸いBeam SDKでは、よく使われる型についてはencodingを自動でやってくれますが、自分でencodingの方法を指定することもできます。</p>
<h3 id="イミュータブル"><span class="head">イミュータブル</span></h3>
<p><code>PCollection</code>は一旦作ったら、追加とか、削除とか、変更とか、できないです。 <code>PTransform</code>では、inputの<code>PCollection</code>は参照するけど変更はされない。</p>
<h3 id="ランダムアクセス"><span class="head">ランダムアクセス</span></h3>
<p><code>PCollection</code>の各要素への<a href="https://kb-jp.sandisk.com/app/answers/detail/a_id/8980/~/%E3%82%B7%E3%83%BC%E3%82%B1%E3%83%B3%E3%82%B7%E3%83%A3%E3%83%AB%E3%82%A2%E3%82%AF%E3%82%BB%E3%82%B9%E3%81%A8%E3%83%A9%E3%83%B3%E3%83%80%E3%83%A0%E3%82%A2%E3%82%AF%E3%82%BB%E3%82%B9%E3%81%AE%E6%93%8D%E4%BD%9C%E3%81%AE%E9%81%95%E3%81%84">ランダムアクセス</a>はサポートしてない。 各要素へのアクセスは、<code>PTransform</code>を経由で行う。</p>
<h3 id="datasetのサイズ"><span class="head">datasetのサイズ</span></h3>
<p><code>PCollection</code>はイミュータブルな（大きい）data。分散処理ができるため？、こいつにサイズ上限はないと謳っている。</p>
<p><code>PCollection</code>として扱うdataは、あらかじめサイズが分かっていても（bounded）、サイズが分からないくてもよい（unbounded）。</p>
<dl>
<dt>
Bounded
</dt>
<dd>
<a href="https://www.idcf.jp/words/batch-processing.html">バッチ処理</a>。 <br> データサイズが分かっているから、全部読み込んで変換処理すればよい。
</dd>
<dt>
unbounded
</dt>
<dd>
<a href="https://www.imkk.jp/blog/what-is-stream-data-processing.html">ストリーミング処理</a>向け。Pub/Subとか、Apache Kafkaがあたる。 <br> データが流れ込み続けるので、<code>pipeline</code>は起動しっぱなしになる。
</dd>
</dl>
<h3 id="要素のタイムスタンプ"><span class="head">要素のタイムスタンプ</span></h3>
<p>Beamでは<code>PCollection</code>の要素にtimestampを割り当てることができる。 ファイルのtimestampとか、Twitterみたいな<code>unbounded</code>なソースだったら、tweetしたときの時間、にできる...？要確認です...。</p>
<p>また、inputのソースにtimestampがついてなければ、<code>PTransform</code>でくっつけることもできる。嬉しい？ことに、inputのdatasetには変更を加えず、timestampだけをつけたPCollectionを返せす<code>PTransform</code>もある(後述)。</p>
</body>
</html>
